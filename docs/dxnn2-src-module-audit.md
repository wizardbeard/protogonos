# DXNN2 `src/` Module Audit (Verified Against `.ref/src`)

This audit is based on the local reference implementation at `.ref/src`.

## Audit date

- 2026-02-21

## Verification source

- Reference root: `.ref/src`
- Files audited: all `.erl` plus `records.hrl`

## Module matrix

Status legend:
- `implemented`: direct functional equivalent exists in current Go codebase.
- `partial`: concept present, but significant behaviors from reference module are missing.
- `missing`: no meaningful equivalent found yet.
- `out-of-scope-now`: not targeted in current AGENTS phase scope.

| Ref module | Primary role (inferred from source) | Go mapping | Status | Evidence |
|---|---|---|---|---|
| `polis.erl` | platform lifecycle, DB bootstrap/start/stop | `internal/platform/polis.go`, `internal/platform/supervisor.go`, `internal/storage/*` with idempotent init/start state, explicit stop lifecycle including `normal`/`shutdown` reason surface and tracked last-stop reason, package-level default runtime registry APIs mirroring singleton `whereis(polis)` semantics (`StartDefault`/`Default`/`StopDefault`) plus `sync/0` analogs (`Polis.Sync`/`SyncDefault`), explicit call/cast protocol analogs (`Call`/`Cast`) for `get_scape`/stop/init message paths processed through a channel-backed mailbox actor loop with explicit init-state payload handling (`InitCast{State: ...}` / `InitWithState`), scape lookup semantics by name plus configured public-scape type (`GetScapeByType`) with insertion-order first-match behavior across dynamic add/remove, configured support-module startup/shutdown plus online add/remove APIs (`AddSupportModule`/`AddSupportModuleWithPolicy`/`RemoveSupportModule`), configured public-scape autostart with tracked scape-summary metadata plus managed lifecycle hooks (including summary-aware startup via `StartWithSummary`) and online add/remove APIs (`AddPublicScape`/`RemovePublicScape`) with explicit `restart_policy`, and Go-native supervision abstraction (`Supervisor`) with restart/backoff policy, strategy support (`one_for_one`/`one_for_all`) including recoverable-failure sibling restart orchestration with policy-aware `temporary`/`transient` handling, child-spec/status metadata surface (`SupervisorChildSpec`/`SupervisorChildStatus` + `ActiveSupervisedChildren`), restart-policy surface (`permanent`/`transient`/`temporary`), restart/permanent-failure hooks, failure-history introspection (`SupervisionFailures`), and optional restart-exhaustion shutdown escalation (`EscalateOnSupervisorFailure`/`SupervisorFailureReason`) for long-lived support-module/public-scape `Supervise(ctx)` loops, explicit `create`/`reset` lifecycle APIs backed by store reset support (shutdown-style reset teardown), and CLI lifecycle wiring via `protogonosctl reset` | `implemented` | `internal/platform/polis.go`, `internal/platform/supervisor.go`, `internal/platform/polis_test.go`, `internal/platform/supervisor_test.go`, `internal/storage/*`, `pkg/protogonos/api.go`, `cmd/protogonosctl/main.go`, `cmd/protogonosctl/main_integration_test.go`, `.ref/src/polis.erl` |
| `population_monitor.erl` | eval loop, evolutionary control, species/population ops | `internal/evo/population_monitor.go` with species-aware evolution loop, lineage/diagnostics, early-stop controls (`fitness_goal`, `evaluations_limit`), `survival_percentage`-driven elite retention derivation, `specie_size_limit` parent-pool capping, pause/continue/stop control-channel semantics via platform/API/CLI (`run_id` live controls), lifecycle trace controls for `goal_reached`/`print_trace`, committee/benchmarker-style trace-update parity via step-sized callbacks (`trace_step_size`, default `500`) and completion callbacks (`TraceUpdateHook`), platform/API/CLI command exposure for those trace controls (`GoalReachedRun`/`PrintTraceRun`, `monitor goal-reached|print-trace`), trace-step config materialization from CLI/config (`--trace-step-size`, `trace_step_size`, `trace.step_size`), step-window `gather_STATS`-style callback accumulation (`step_evaluations`, `step_cycles`, `step_time`, per-species evaluation counts), expanded per-species stats payload in callbacks (fitness mean/std/min/max, neuron mean/std, diversity), optional species-champion validation/test probe metrics in callbacks (`validation_probe`/`test_probe`, `--validation-probe`/`--test-probe`) with explicit mode-aware routing to `validation`/`test` when supported by the active scape and validation-triggered test probing semantics, steadier reference-closer `steady_state` replacement behavior (single-offspring replacement per cycle, not whole-population replacement), continuation from persisted population snapshots via `continue_population_id`, success-only mutation-step retry semantics (failed/inapplicable mutators do not decrement requested mutation count), fail-fast IO compatibility validation, generation-offset continuation semantics, persisted `initial_generation` run metadata, default continuation identity reuse (`run_id <- continue_population_id`), append-on-continue history persistence for same-run continuation, map2rec `pmp.population_id` continuation-default materialization, explicit evolution-type wiring for `generational`/`steady_state` (`constraint.population_evo_alg_f` + `pmp.evolution_type`) with steady-state runtime behavior/tests, reference-closer `goal_reached` accounting (post-signal evaluations are no longer counted), in-flight control processing while waiting on worker results (so command handling is not deferred to boundary-only drains), and explicit `delete_population` lifecycle deletion command path | `implemented` | `internal/evo/population_monitor.go`, `internal/evo/population_monitor_test.go`, `internal/platform/polis_evolution_test.go`, `internal/platform/polis.go`, `internal/genotype/store.go`, `internal/morphology/regression_mimic.go`, `internal/stats/artifacts.go`, `cmd/protogonosctl/config.go`, `cmd/protogonosctl/main_integration_test.go`, `cmd/protogonosctl/main.go`, `pkg/protogonos/api_test.go`, `.ref/src/population_monitor.erl` |
| `cortex.erl` | sensor/neuron/actuator runtime coordination | `internal/agent/cortex.go` with sensor->forward->actuator orchestration, vector/chunked actuator dispatch support, explicit lifecycle states (`active`/`inactive`/`terminated`), reactivation/reset semantics, reference-style actuator sync-feedback episode aggregation (`fitness_acc`/`endflag`/cycle/time/goal via `RunUntilEvaluationComplete`), and runtime weight backup/restore/perturb APIs mirroring neuron message semantics | `implemented` | `internal/agent/cortex.go`, `internal/agent/cortex_test.go`, `.ref/src/cortex.erl` |
| `exoself.erl` | agent lifecycle + tuning + eval mode orchestration | `internal/tuning/exoself.go` + monitor integration with minimum-improvement acceptance threshold parity (`MIN_PIMPROVEMENT`-style) via relative dominance gating (`candidate > incumbent + incumbent*mip`), consecutive non-improvement attempt budgeting with reset-on-improvement semantics, goal-aware early stop (`fitness_goal`), perturbation controls (`perturbation_range`/`annealing_factor`), tuning-selection/vector helper parity (`transpose`/`vector_avg`/`vector_basic_stats`), per-generation tuning telemetry in diagnostics/artifacts, explicit `op_mode` routing (`gt`/`validation`/`test`) and composite/list parsing (`[gt,validation,test]`), plus full actor-level orchestration parity through runtime exoself sessions (`TuneRuntimeWithReport`) that execute backup/restore/reactivate/apply loops on persistent cortex instances and are dispatched by monitor workers in `gt` mode | `implemented` | `internal/tuning/exoself.go`, `internal/tuning/exoself_test.go`, `internal/tuning/tuner.go`, `internal/evo/population_monitor.go`, `internal/evo/population_monitor_test.go`, `internal/evo/population_monitor_tuning_test.go`, `internal/agent/cortex.go`, `internal/agent/cortex_test.go`, `internal/platform/polis.go`, `internal/model/types.go`, `cmd/protogonosctl/main.go`, `cmd/protogonosctl/main_integration_test.go`, `cmd/protogonosctl/config.go`, `cmd/protogonosctl/config_test.go`, `pkg/protogonos/api.go`, `pkg/protogonos/api_test.go`, `.ref/src/exoself.erl` |
| `neuron.erl` | neuron actor runtime, integrator/plasticity hooks | `internal/nn/network.go` with activation/aggregator forward path and reference-aligned output saturation (`[-1,1]`), recurrent synapse prior-step memory support when runtime state is provided, and per-target-neuron plasticity rule/rate precedence in runtime updates, plus cortex-exposed runtime weight backup/restore/perturb protocol analogs | `implemented` | `internal/nn/network.go`, `internal/nn/network_test.go`, `internal/nn/plasticity.go`, `internal/nn/plasticity_test.go`, `internal/agent/cortex.go`, `internal/agent/cortex_test.go`, `.ref/src/neuron.erl` |
| `sensor.erl` | sensor actor implementations + scape IO | `internal/io/*` | `partial` | `internal/io/interfaces.go`, `internal/io/scalar_components.go`, `.ref/src/sensor.erl` |
| `actuator.erl` | actuator actor implementations + scape IO | `internal/io/*` | `partial` | `internal/io/interfaces.go`, `internal/io/scalar_components.go`, `.ref/src/actuator.erl` |
| `scape.erl` | benchmark environments (xor, pole balancing, fx, dtm, etc.) | `internal/scape/*` with direct scape coverage for xor/regression/cart-pole-lite/pole2-balancing/dtm/flatland/gtsa/fx/epitopes/llvm-phase-ordering, mode-aware evaluation routing now including explicit windows on xor/regression/cart-pole-lite/flatland/dtm/pole2 plus delegated families and cross-scape `benchmark` alias support, reference-name alias normalization (`*_sim`, `*_sim1`, `*_v1`, `scape_*`) across runtime lookup/compatibility/seed construction (including flatland/epitopes/fx/gtsa/llvm families), TickAgent sensor/actuator execution support for flatland/gtsa/fx/epitopes/llvm/dtm in addition to step-runner evaluation, richer flatland metabolics/collision respawn-cycle behavior now including wall barriers, resource potency growth, and relocation-based respawn lifecycles, deeper GTSA table/window diagnostics with per-agent index progression (`index_start`/`index_current`/`index_end`) and rolling-window metadata plus optional TickAgent internal-state channels (`gtsa_delta`/`gtsa_window_mean`/`gtsa_progress`) and optional CSV table ingestion/bound overrides, FX account/order lifecycle simulation plus enriched step-percept internals, optional internal-state sensor channels, and optional CSV price-series ingestion, expanded pole2/dtm runtime telemetry parity (damping-style pole2 fitness accumulation + terminal reasons with reference GT `100000` step budgets, optional vector push-controls for damping/double-pole flags, and TickAgent sensing-surface subset support for parameterized pole2 channels; plus reference-style non-timeout DTM run-step accounting, TickAgent subset support for `all`/`range_sense`/`reward` DTM sensing surfaces, and optional DTM workflow-state channels `dtm_run_progress`/`dtm_step_progress`/`dtm_switched`), XOR scorer parity alignment to reciprocal-SSE semantics (`1/(SSE+1e-6)`), deeper epitopes/llvm surrogates (sequence-feature windows, table-driven session windows, optional TickAgent internal-state channels `epitopes_target`/`epitopes_progress`/`epitopes_margin`, optional LLVM workflow-state channels `llvm_alignment`/`llvm_diversity`/`llvm_runtime_gain`, and optional CSV table ingestion for external row sets, plus LLVM vector optimization-surface selection/telemetry), and run-surface dataset configuration support (API/CLI/config-file fields + persisted run artifacts for GTSA/FX/Epitopes CSV paths and bounds plus LLVM workflow JSON paths) plus context-scoped source binding (`WithDataSources`) for run-level isolation in the surrogate runtime (including scoped LLVM workflow sources), with flatland run-level override controls now including scanner/layout/trials and episode bounds (`max_age`, `forage_goal`) via API/CLI/config/context wiring | `partial` | `internal/scape/xor.go`, `internal/scape/regression_mimic.go`, `internal/scape/cart_pole_lite.go`, `internal/scape/pole2_balancing.go`, `internal/scape/dtm.go`, `internal/scape/flatland.go`, `internal/scape/gtsa.go`, `internal/scape/fx.go`, `internal/scape/epitopes.go`, `internal/scape/llvm_phase_ordering.go`, `internal/scapeid/normalize.go`, `internal/io/registry.go`, `internal/morphology/regression_mimic.go`, `internal/genotype/lifecycle.go`, `internal/platform/polis.go`, `pkg/protogonos/api.go`, `.ref/src/scape.erl` |
| `morphology.erl` | morphology catalogs + init/full sensor/actuator selection | `internal/morphology/*` | `partial` | `internal/morphology/regression_mimic.go`, `internal/morphology/xor.go`, `.ref/src/morphology.erl` |
| `genome_mutator.erl` | mutation operator suite | `internal/evo/mutations.go` with explicit reference-name mutators for `mutate_weights`, `add_bias`/`remove_bias`, `mutate_af`/`mutate_aggrf`, `mutate_pf`, `mutate_plasticity_parameters`, `add_neuron`, and `remove_neuron`; reference-closer `mutate_weights` semantics via tuning-selection-aware neuron targeting with proportional incoming-weight perturbation (`1/sqrt(incoming_weights)` + at-least-one fallback); dedicated directional add/remove link operators for `add_inlink`/`add_outlink`/`remove_inlink`/`remove_outlink` without non-directional fallback when directional candidates are absent and with feedforward layer-order gating in default feedforward mode, with `add_inlink` now also considering sensor->neuron endpoint-link candidates; explicit splice operators for `outsplice`/`insplice` with directional candidate gating and feedforward edge filtering in feedforward mode plus exhaustion/no-synapse cancellation via `ErrNoMutationChoice`; explicit sensor/actuator add/remove mutation operators for `add_sensor`/`add_sensorlink`/`add_actuator`/`add_actuatorlink`/`remove_sensor`/`remove_actuator` filtered by scape-compatible IO registry entries with split component-vs-link semantics (`add_sensor` auto-connects one initial endpoint link and `add_actuator` now builds a helper-neuron scaffold with one helper synapse plus one initial actuator endpoint link, `add_*link` appends additional explicit endpoint links, `remove_*` removes selected endpoint and its explicit links, with legacy link counters synchronized, and now cancels on empty/exhausted choice pools instead of no-op success); explicit cutlink alias operators for `cutlink_FromElementToElement`/`cutlink_FromNeuronToNeuron`/`cutlink_FromSensorToNeuron`/`cutlink_FromNeuronToActuator`; explicit link helper aliases for `link_FromElementToElement`/`link_FromNeuronToNeuron`/`link_FromSensorToNeuron`/`link_FromNeuronToActuator`, with generic element-link helpers now selecting across synapse/sensor-link/actuator-link pools and canceling when all candidate pools are exhausted and with neuron-only helper aliases now using candidate-aware applicability plus cancellation on exhausted pools; explicit substrate-structure operators for `add_cpp`/`remove_cpp`/`add_cep`/`remove_cep` with cancellation when no alternative CPP/CEP registry choice exists, with `add_cpp` now appending one sensor->neuron scaffold link when compatible endpoint candidates exist and `add_cep` appending a helper-neuron synapse scaffold when neurons are present; substrate-dimension circuit mutation operators for `add_circuit_node`/`delete_circuit_node`/`add_circuit_layer` now cancel when substrate/dimension prerequisites are missing and remain gated to substrate-configured genomes; legacy mutation names are canonicalized during config/profile ingestion (`add_CircuitNode` -> `add_circuit_node`, `remove_outLink` -> `remove_outlink`, etc.); config and profile mutation ingestion now share a single canonical operator-to-weight-bucket resolver with exhaustive must-have operator-surface tests; explicit search-parameter mutator operators for `mutate_tuning_selection`/`mutate_tuning_annealing`/`mutate_tot_topological_mutations`/`mutate_heredity_type` with expanded reference tuning-selection mode coverage (`dynamic`/`dynamic_random`/`active`/`active_random`/`recent`/`recent_random`/`all`/`all_random`/`current`/`current_random`/`lastgen`/`lastgen_random`) and cancellation when no alternative strategy option exists, with `Applicable` now reflecting alternative-choice availability for singular configured choice sets; function-choice mutators (`mutate_af`/`mutate_aggrf`/`mutate_pf`) now also cancel when no alternative function choice exists and report inapplicable state when constrained choice sets provide no alternatives; plasticity/substrate-parameter mutators (`perturb_plasticity_rate`/`change_plasticity_rule`/`perturb_substrate_parameter`) now cancel when required config or candidate choices are unavailable; `remove_neuron` now cancels when all neurons are protected/non-removable; duplicate directed-edge creation for add-link mutators is now rejected; directional add/remove link exhausted candidate pools now cancel with `ErrNoMutationChoice`; sensor/actuator link mutators now enforce full-connectivity ceilings with `ErrNoMutationChoice` cancellation semantics and also cancel when required component pools are empty; cutlink IO aliases now cancel with `ErrNoMutationChoice` when endpoint-link pools are empty; `mutate_tot_topological_mutations` now mutates function mode and parameter together in genome strategy metadata; `mutate_pf` and `mutate_plasticity_parameters` now mutate per-neuron plasticity metadata; and operator-name parity aligned to reference tags for lineage/reporting output | `implemented` | `internal/evo/mutations.go`, `internal/evo/mutations_test.go`, `cmd/protogonosctl/config.go`, `cmd/protogonosctl/profiles.go`, `pkg/protogonos/api.go`, `.ref/src/genome_mutator.erl` |
| `selection_algorithm.erl` | selection strategy variants | `internal/evo/selection.go` + monitor integration + CLI/API alias mapping (`hof_competition`/`hof_rank`/`hof_top3`/`hof_efficiency`/`hof_random`/`competition`/`top3`) and map2rec config materialization via `constraint.population_selection_f` | `implemented` | `internal/evo/selection.go`, `internal/evo/population_monitor.go`, `cmd/protogonosctl/main.go`, `cmd/protogonosctl/config.go`, `cmd/protogonosctl/profiles.go`, `pkg/protogonos/api.go`, `.ref/src/selection_algorithm.erl` |
| `tuning_selection.erl` | exoself selection schedule variants | `internal/tuning/exoself.go` with reference mode-name coverage (`dynamic`/`dynamic_random`/`active`/`active_random`/`current`/`current_random`/`all`/`all_random`) and legacy aliases (`recent`/`recent_random`/`lastgen`/`lastgen_random`) via CLI/API/config normalization, including probabilistic `*_random` subset selection (`1/sqrt(N)` + non-empty fallback), generation-aware age filtering inferred from genome IDs, `all`/`all_random` full-pool behavior, `lastgen*` alias alignment to current-generation selection semantics, reference-aligned mode-specific empty-pool fallback behavior in exoself and `mutate_weights` (`active` no fallback/no-op; `active_random`/`current*`/`dynamic*` first-candidate fallback), exoself age-annealed spread application (`perturbation_range*pi*annealing^age`) with direct actuator-local perturbation (per-actuator tunables), and mirrored age-annealed direct actuator-target handling in `mutate_weights` using neuron/actuator generation metadata with tagged-ID fallback | `implemented` | `internal/tuning/exoself.go`, `internal/tuning/exoself_test.go`, `cmd/protogonosctl/main.go`, `pkg/protogonos/api.go`, `cmd/protogonosctl/config.go`, `.ref/src/tuning_selection.erl` |
| `tuning_duration.erl` | tuning-attempt duration policies | `internal/tuning/policy.go` + API/CLI/config alias normalization (`const`/`nsize_proportional`/`wsize_proportional`) with distinct `nsize_proportional` and `wsize_proportional` attempt formulas | `implemented` | `internal/tuning/policy.go`, `internal/tuning/policy_test.go`, `pkg/protogonos/api.go`, `cmd/protogonosctl/config.go`, `.ref/src/tuning_duration.erl` |
| `tot_topological_mutations.erl` | mutation-count policy functions | `internal/evo/topological_mutations.go` + monitor integration + map2rec constraint materialization into run config, including stochastic `ncount_exponential` range semantics aligned to reference (`uniform(1..round(n^power))`) | `implemented` | `internal/evo/topological_mutations.go`, `internal/evo/topological_mutations_test.go`, `internal/evo/population_monitor.go`, `cmd/protogonosctl/config.go`, `.ref/src/tot_topological_mutations.erl` |
| `functions.erl` | activation/math utility set | activation registry plus non-activation utility parity surface in `internal/nn/functions.go` (`saturation`/`sat`/`sat_dzone`/`scale`, `avg`/`std`, vector/coordinate helpers, IOW variants, and explicit-state `s/1` analogue via `XORDemoStep`) | `implemented` | `internal/nn/registry.go`, `internal/nn/registry_test.go`, `internal/nn/functions.go`, `internal/nn/functions_test.go`, `.ref/src/functions.erl` |
| `derivatives.erl` | derivative functions for activations | `internal/nn/derivatives.go` with expanded reference-style derivative surface (`linear`/`sigmoid1`/`multiquadric`/`sqrt`/`log` plus clipping parity for `sigmoid`/`gaussian`) | `implemented` | `internal/nn/derivatives.go`, `internal/nn/derivatives_test.go`, `.ref/src/derivatives.erl` |
| `plasticity.erl` | Hebbian/Oja/etc plasticity rules | `internal/nn/plasticity.go` + cortex integration with explicit PF handling for `hebbian`/`hebbian_w`, `oja`/`ojas`/`ojas_w`, `self_modulationV1..V6`, and `neuromodulation`; `hebbian_w`/`ojas_w` use per-synapse learning parameters (`synapse.plasticity_params`) with fallback-rate behavior, self-modulation retains per-target-neuron rule/rate precedence and generalized Hebbian coefficients (`A/B/C/D`) with dynamic-term extraction from both synapse and bias vectors (`plasticity_params`/`plasticity_bias_params`), and neuromodulation dead-zone scaling is integrated; mutation choreography now aligns to rule families via `mutate_pf` (rule-transition neural default reseeding + rule-family vector-width reseeding/clearing) and `mutate_plasticity_parameters` (rule-width vector perturbation `1/sqrt(total_parameters)`, V2/V3/V5 coefficient schedules, signed `hebbian`/`oja` neural-parameter updates, neuromodulation `[rate,A,B,C,D]` `1/sqrt(5)` scheduling, input-before-bias traversal ordering, and `none` cancellation with empty-neuron-rule fallback to genome defaults) | `implemented` | `internal/nn/plasticity.go`, `internal/nn/plasticity_test.go`, `internal/model/types.go`, `internal/genotype/clone.go`, `internal/genotype/genotype_test.go`, `internal/evo/mutations.go`, `internal/evo/mutations_test.go`, `internal/agent/cortex.go`, `.ref/src/plasticity.erl` |
| `signal_aggregator.erl` | dot/mult/diff aggregation modes | selectable per-neuron aggregation in forward path with reference-aligned multiplicative `mult_product` behavior and stateful `diff_product` previous-input differencing semantics across cortex steps | `implemented` | `internal/nn/network.go`, `internal/nn/network_test.go`, `internal/agent/cortex.go`, `internal/agent/cortex_test.go`, `.ref/src/signal_aggregator.erl` |
| `genotype.erl` | construction/cloning/deletion/fingerprint topologies | seed builders + model/store basics + topology fingerprint/signature + genotype utility package | `partial` | `cmd/protogonosctl/main.go`, `pkg/protogonos/api.go`, `internal/model/types.go`, `internal/genotype/*`, `.ref/src/genotype.erl` |
| `specie_identifier.erl` | species topology identifiers | `internal/evo/specie_identifier.go` + species tournament selector with explicit `tot_n` parity mapping (and topology fallback), wired through config/API/runtime selection | `implemented` | `internal/evo/specie_identifier.go`, `internal/evo/specie_identifier_test.go`, `internal/evo/selection.go`, `cmd/protogonosctl/config.go`, `pkg/protogonos/api.go`, `.ref/src/specie_identifier.erl` |
| `fitness_postprocessor.erl` | post-fitness adjustment (size/novelty) | `internal/evo/fitness_postprocessor.go` + monitor integration + CLI/API alias mapping (`nsize_proportional`) + map2rec config materialization (`constraint.population_fitness_postprocessor_f`) + reference `size_proportional` exponent parity (`EFF=0.05`) + reference `novelty_proportional` placeholder parity (no-op) | `implemented` | `internal/evo/fitness_postprocessor.go`, `internal/evo/fitness_postprocessor_test.go`, `internal/evo/population_monitor.go`, `cmd/protogonosctl/main.go`, `cmd/protogonosctl/config.go`, `pkg/protogonos/api.go`, `.ref/src/fitness_postprocessor.erl` |
| `benchmarker.erl` | experiment orchestration/reporting/graphs | `benchmark` command + artifacts + profile resolution views, including persisted best-series summary stats (`best_mean`/`best_std`/`best_min`/`best_max`) in benchmark artifacts | `partial` | `cmd/protogonosctl/main.go`, `cmd/protogonosctl/profiles.go`, `internal/stats/artifacts.go`, `.ref/src/benchmarker.erl` |
| `map2rec.erl` | map->record conversion helpers | `internal/map2rec` with broad record-materialization parity (`constraint`/`pmp`/`experiment`/`circuit`/`layer`/`layer2`/`layer_spec`/`neurode`/`sensor`/`actuator`/`neuron`/`agent`/`cortex`/`substrate`/`polis`/`scape`/`sector`/`avatar`/`object`/`circle`/`square`/`line`/`e`/`a`/`specie`/`population`/`trace`/`stat`/`topology_summary`/`signature`/`champion`), including list-valued `pmp.op_mode` materialization, plus runtime use in profile/config ingestion (`run`/`benchmark --config`) | `implemented` | `internal/map2rec/convert.go`, `internal/map2rec/convert_test.go`, `cmd/protogonosctl/profiles.go`, `cmd/protogonosctl/config.go`, `cmd/protogonosctl/main.go`, `cmd/protogonosctl/main_integration_test.go`, `.ref/src/map2rec.erl` |
| `records.hrl` | central schema/extensibility surface | full record-equivalent schema materialization (`internal/map2rec/types.go`) + defaults/fallback conversion coverage (`internal/map2rec/convert.go`) + versioned record-envelope codec support across all record kinds (`internal/map2rec/codec.go`) + extension registries (`internal/io/registry.go`, `internal/evo/registry.go`, `internal/nn/registry.go`) | `implemented` | `internal/map2rec/types.go`, `internal/map2rec/convert.go`, `internal/map2rec/convert_test.go`, `internal/map2rec/codec.go`, `internal/map2rec/codec_test.go`, `internal/io/registry.go`, `internal/evo/registry.go`, `internal/nn/registry.go`, `.ref/src/records.hrl` |
| `dxnn2_app.erl` | OTP application entrypoint | `cmd/protogonosctl/main.go` | `out-of-scope-now` | `cmd/protogonosctl/main.go`, `.ref/src/dxnn2_app.erl` |
| `flatland.erl` | interactive multi-agent world/scape server | `internal/scape/flatland.go` with scalar-IO world surrogate including metabolics, collision events, respawn timers, terminal-cause tracking, wall-barrier penalties, resource potency growth, and relocation-based respawn cycling with expanded trace telemetry | `partial` | `internal/scape/flatland.go`, `internal/scape/flatland_test.go`, `.ref/src/flatland.erl` |
| `fx.erl` | financial simulation/evaluation tooling | `internal/scape/fx.go` with account/order lifecycle surrogate (`open`/`close`/flip semantics, realized/unrealized P/L, drawdown and margin-call tracking, mode windows), enriched feature-percept internals, optional internal-state sensor channel wiring (`fx_momentum`/`fx_volatility`/`fx_nav`/`fx_drawdown`/`fx_position`/`fx_entry`/`fx_percent_change`/`fx_profit`) through morphology/IO/seed scaffolding, and optional external CSV price-series ingestion with trace-level source metadata (`series_name`/`series_points`) | `partial` | `internal/scape/fx.go`, `internal/scape/fx_test.go`, `internal/morphology/fx.go`, `internal/io/scalar_components.go`, `internal/genotype/lifecycle.go`, `.ref/src/fx.erl` |
| `scape_GTSA.erl` | time-series scape process | `internal/scape/gtsa.go` with table-backed series windows, per-agent index state progression and rolling-window metadata, TickAgent internal-state channel wiring (`gtsa_delta`/`gtsa_window_mean`/`gtsa_progress`) with default morphology/seed scaffolding, prediction diagnostics (`mse`/`mae`/direction/jitter) across mode windows, and optional CSV-backed table ingestion with explicit train/validation/test cutoffs | `partial` | `internal/scape/gtsa.go`, `internal/scape/gtsa_test.go`, `internal/morphology/gtsa.go`, `internal/io/scalar_components.go`, `internal/genotype/lifecycle.go`, `.ref/src/scape_GTSA.erl` |
| `substrate.erl` | substrate encoding runtime | `internal/substrate/runtime.go` + cortex/monitor integration | `partial` | `internal/substrate/runtime.go`, `internal/agent/cortex.go`, `internal/evo/population_monitor.go`, `.ref/src/substrate.erl` |
| `substrate_cpp.erl` | substrate CPP runtime | `internal/substrate/components.go` + registry | `partial` | `internal/substrate/components.go`, `internal/substrate/registry.go`, `.ref/src/substrate_cpp.erl` |
| `substrate_cep.erl` | substrate CEP runtime | `internal/substrate/components.go` + registry | `partial` | `internal/substrate/components.go`, `internal/substrate/registry.go`, `.ref/src/substrate_cep.erl` |
| `visor.erl` | visualization loop/UI drawing | none | `out-of-scope-now` | `.ref/src/visor.erl` |
| `epitopes.erl` | experiment/sim utility tooling | `internal/scape/epitopes.go` deterministic scape-level surrogate with table-driven sense/classify sessions, mode windows, optional TickAgent internal-state channels (`epitopes_target`/`epitopes_progress`/`epitopes_margin`) backed by morphology/IO/seed defaults, and optional external CSV table ingestion (`LoadEpitopesTableCSV`/`ResetEpitopesTableSource`) for data-driven row sets | `partial` | `internal/scape/epitopes.go`, `internal/scape/epitopes_test.go`, `internal/morphology/epitopes.go`, `internal/io/scalar_components.go`, `internal/genotype/lifecycle.go`, `.ref/src/epitopes.erl` |
| `data_extractor.erl` | dataset ingestion and conversion tooling | baseline extractor workflow via `protogonosctl data-extract` + `internal/dataextract` for GTSA/FX/Epitopes canonical CSV output from raw CSV column selections | `partial` | `cmd/protogonosctl/data_extract.go`, `internal/dataextract/extract.go`, `internal/dataextract/extract_test.go`, `.ref/src/data_extractor.erl` |

## Summary

- `implemented`: 18
- `partial`: 13
- `missing`: 0
- `out-of-scope-now`: 3

Most core AGENTS responsibilities are present, with remaining `partial` modules concentrated in environment/runtime breadth and substrate-family depth. The largest parity gaps are:

1. Full scape behavior depth for complex reference environments (flatland/fx/gtsa/epitopes/llvm family) beyond baseline parity surrogates.
2. Substrate encoding family behavior depth (`substrate.erl`, `substrate_cpp.erl`, `substrate_cep.erl`).

## Recommended next parity increments

1. Deepen scape behavior parity (`scape.erl`) and corresponding sensor/actuator/morphology semantics toward reference runtime depth.
2. Complete substrate-family behavior parity (`substrate.erl`, `substrate_cpp.erl`, `substrate_cep.erl`) and benchmarking/reporting depth.
